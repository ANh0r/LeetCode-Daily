class Solution {
public:
    int nthUglyNumber(int n) {
        int nums[1690];
        nums[0] = 1;
        int i2 = 0;
        int i3 = 0;
        int i5 = 0;
        for (int i = 1; i < 1690; ++i)
        {
            int currUgly = min(min(nums[i2]*2, nums[i3]*3), nums[i5]*5);
            nums[i] = currUgly;

            if (currUgly == nums[i2]*2)
            {
                ++i2;
            }
            if (currUgly == nums[i3]*3)
            {
                ++i3;
            }
            if (currUgly == nums[i5]*5)
            {
                ++i5;
            }
        }

        return nums[n-1];
    }
};
// 丑数是只含有2 3 5为因子的数字，及代表 4  = 2 * 2 也是丑数
// 三个指针维护三个丑数下标 保证已经进入数组的都是遍历后最小的丑数
// 判断最小：当前的已经存在的丑数下标分别乘以2 3 5 找出最小
// 去重：最小值加入数组后，判断加入的数字和已经进行计算
/*
第一个是每次对计算出三个丑数并取最小，这里需要计算三个丑数，
一定有两个丑数是在上一次中就已经被计算并比较过的，因为较大所以被筛掉了两个（这两个进入下次比较中），
留下较小的那个，并自增一次最小值的下标i，使得参与下次计算时能稍微增大，并同该次比较中淘汰的两个稍大数比较
，经过这样的不断比较+迭代，能保证结果集是按从小到大的（此处结果集理论是有重复值，但实际没有）

第二个关键点在于自增每次的最小丑数值的下标，这么做一是可以迭代避免重复计算，从而避免出现重复值，
二是避免遗漏。因为按照最直接的理解与解法，每个数都需分别*2，*3，*5加入数组，
历经n次，最后再排序，但通过设置三个从0开始的下标，
使其对应的值分别只与2或3或5相乘，而每个下标都有机会迭代，
这样可以保证数组中的每个数实际都是分别与2、3、5乘一次，
数组中的前四个数是1,2,3,5，后面的数都是由前面的数分别与2、3、5相乘计算出来的，
这样也满足了丑数的定义，并且每次计算的数都是先排序再加入的，如此可以避免不漏且排序。
不重复数字 是通过三个if判断解决的，因为假如一个数既可通过*2得到又可以通过*3得到，此时必然会重复计算并重复加入到数组，
因此此时需要既迭代2对应的下标p2，也迭代3对应的下标p3，所以if如果换成if-else,必然会有大量重复值出现
*/